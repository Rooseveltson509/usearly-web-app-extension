{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AAC0E,CAAC;AAC3E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E,mDAAmD,kCAAkC;AACrF,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAS,oBAAoB;AACrD;AACA,wBAAwB,gEAAY,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,qDAAqD,2BAA2B,wBAAwB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,oBAAoB;AACtG,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB,IAAI;AAC7B;AACA,qBAAqB;AACrB,iBAAiB,IAAI;AACrB,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6CAA6C,6DAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kCAAkC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;;;;;;;;;;;;;;;;;ACjGF;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA,0CAA0C,4BAA4B,6BAA6B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE;AACF,oCAAoC,4BAA4B;AAChE;AACA;AACA,aAAa;AACb,IAAI;AACJ,oDAAoD,4BAA4B,6BAA6B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA,oBAAoB;AACpB;AACO;AACP,2CAA2C;AAC3C,+BAA+B,0BAA0B;AACzD;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,wCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qCAAqC;AAC/E,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;UCnJA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACN2D;AACF;AACT;AAChD;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,kCAAkC;AAClC,IAAI;AACJ,iCAAiC;AACjC;AACA,CAAC,GAAG;AACJ;AACA;AACA,YAAY,sEAAc;AAC1B;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA,2EAA2E,QAAQ;AACnF,iBAAiB;AACjB,aAAa,WAAW;AACxB;AACA;AACA,CAAC;AACD;AACA,4CAA4C;AAC5C,2BAA2B;AAC3B;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA;AACA,2CAA2C,yDAAyD;AACpG;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,oDAAoD;AACvF;AACA,aAAa;AACb,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C;AAC7E,iBAAiB,SAAS;AAC1B;AACA;AACA,+BAA+B,oCAAoC;AACnE;AACA,2CAA2C,kCAAkC;AAC7E,iBAAiB;AACjB,gDAAgD,yBAAyB;AACzE;AACA;AACA,6CAA6C;AAC7C;AACA,wBAAwB,6DAAS;AACjC,mDAAmD,uBAAuB,GAAG;AAC7E;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,sCAAsC;AACzE,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA,yBAAyB;AACzB;AACA,gCAAgC;AAChC,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA,YAAY,6DAAS;AACrB,+BAA+B,uCAAuC;AACtE,aAAa;AACb,yBAAyB;AACzB;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA;AACA,CAAC","sources":["webpack://usearly-extension-react/./src/services/AuthService.ts","webpack://usearly-extension-react/./src/utils/blockAdultSites.ts","webpack://usearly-extension-react/./src/utils/storageUtil.ts","webpack://usearly-extension-react/webpack/bootstrap","webpack://usearly-extension-react/webpack/runtime/define property getters","webpack://usearly-extension-react/webpack/runtime/hasOwnProperty shorthand","webpack://usearly-extension-react/webpack/runtime/make namespace object","webpack://usearly-extension-react/./src/background.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { setTokens, setLoginTime, getTokens } from '../utils/storageUtil'; // Mise à jour pour chrome.storage\n//const API_URL = 'https://usearlyapi.fly.dev/api/v1';\nvar API_URL = 'http://localhost:3000/api/v1';\nexport function login(email, password) {\n    return __awaiter(this, void 0, void 0, function () {\n        var response, data, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 3, , 4]);\n                    return [4 /*yield*/, fetch(\"\".concat(API_URL, \"/user/login\"), {\n                            method: 'POST',\n                            headers: { 'Content-Type': 'application/json' },\n                            body: JSON.stringify({ email: email, password: password }),\n                        })];\n                case 1:\n                    response = _a.sent();\n                    if (!response.ok) {\n                        console.error(\"\\u00C9chec de la connexion (\".concat(response.status, \"):\"), response.statusText);\n                        // Optionnel : affiche un message utilisateur basé sur le code d'état HTTP\n                        if (response.status === 401) {\n                            //alert(\"Identifiants incorrects. Veuillez réessayer.\");\n                        }\n                        else if (response.status >= 500) {\n                            //alert(\"Erreur serveur. Veuillez réessayer plus tard.\");\n                        }\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, response.json()];\n                case 2:\n                    data = _a.sent();\n                    if (data.accessToken) {\n                        setTokens(data.accessToken); // Stocke uniquement l'accessToken\n                        console.log(\"Connexion réussie. Token stocké.\");\n                        setLoginTime(); // Met à jour l'heure de connexion\n                        return [2 /*return*/, true];\n                    }\n                    console.error(\"Aucun accessToken reçu.\");\n                    alert(\"Une erreur inattendue est survenue. Veuillez réessayer.\");\n                    return [2 /*return*/, false];\n                case 3:\n                    error_1 = _a.sent();\n                    console.error(\"Erreur lors de la connexion :\", error_1);\n                    alert(\"Impossible de se connecter. Veuillez vérifier votre connexion réseau.\");\n                    return [2 /*return*/, false];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function isUserAuthenticated() {\n    return __awaiter(this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {\n                    var _this = this;\n                    return __generator(this, function (_a) {\n                        chrome.runtime.sendMessage({ action: 'isAuthenticated' }, function (response) { return __awaiter(_this, void 0, void 0, function () {\n                            var loginTime, elapsedTime, FIVE_HOURS_IN_MS;\n                            var _a;\n                            return __generator(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        if (!chrome.runtime.lastError) return [3 /*break*/, 1];\n                                        console.error(\"Erreur de communication avec le script de fond :\", chrome.runtime.lastError.message);\n                                        resolve(false);\n                                        return [3 /*break*/, 3];\n                                    case 1: return [4 /*yield*/, getLoginTime()];\n                                    case 2:\n                                        loginTime = _b.sent();\n                                        if (loginTime) {\n                                            elapsedTime = Date.now() - loginTime;\n                                            FIVE_HOURS_IN_MS = 24 * 60 * 60 * 1000;\n                                            //const FIVE_HOURS_IN_MS = 5 * 60 * 60 * 1000; \n                                            if (elapsedTime >= FIVE_HOURS_IN_MS) {\n                                                //console.log(`Temps écoulé ::: ${elapsedTime / 1000} secondes. Déconnexion.`);\n                                                logout(); // Déconnectez si 20 secondes sont écoulées\n                                                resolve(false);\n                                            }\n                                            else {\n                                                console.log(\"Temps restant avant d\\u00E9connexion ::: \".concat((FIVE_HOURS_IN_MS - elapsedTime) / 1000, \" secondes.\"));\n                                                resolve((_a = response === null || response === void 0 ? void 0 : response.isAuthenticated) !== null && _a !== void 0 ? _a : false);\n                                            }\n                                        }\n                                        else {\n                                            resolve(false); // Aucun login enregistré\n                                        }\n                                        _b.label = 3;\n                                    case 3: return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                        return [2 /*return*/];\n                    });\n                }); })];\n        });\n    });\n}\n// Récupère l'heure de connexion\nexport function getLoginTime() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve) {\n                    chrome.storage.local.get(['loginTime'], function (result) {\n                        resolve(result.loginTime || null);\n                    });\n                })];\n        });\n    });\n}\nexport function logout() {\n    chrome.storage.local.remove([\"accessToken\", \"refreshToken\", \"loginTime\"], function () {\n        if (chrome.runtime.lastError) {\n            console.error(\"Erreur lors de la déconnexion :\", chrome.runtime.lastError.message);\n        }\n        else {\n            console.log(\"Déconnexion réussie, données supprimées.\");\n        }\n    });\n}\n// Récupère un token valide (soit l'Access Token actuel, soit un nouveau)\nexport function getValidToken() {\n    return __awaiter(this, void 0, void 0, function () {\n        var tokens;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, getTokens()];\n                case 1:\n                    tokens = _a.sent();\n                    // Vérifie si l'accessToken existe\n                    if (tokens.accessToken) {\n                        return [2 /*return*/, tokens.accessToken];\n                    }\n                    console.warn(\"Aucun accessToken valide trouvé.\");\n                    return [2 /*return*/, null];\n            }\n        });\n    });\n}\n","// Liste noire de domaines connus pour adultes\nvar forbiddenDomains = [\n    \"exampleporn.com\",\n    \"violentsite.com\",\n    \"adult-content.com\",\n    \"badsites.net\",\n    \"pornhub.com\",\n    \"pornhub.com\",\n    \"xvideos.com\",\n    \"redtube.com\",\n    \"xnxx.com\",\n    \"youporn.com\",\n    \"brazzers.com\",\n    \"adultfriendfinder.com\",\n    \"livejasmin.com\",\n    \"airbnb.fr\",\n    \"fr.pornhub.com\",\n    \"nike.com\",\n    \"fr.pornhub\",\n];\nvar forbiddenKeywords = [\n    \"porn\",\n    \"violent\",\n    \"xxx\",\n    \"porn+hardcor+violent\",\n    \"pornhub\",\n    \"murder\",\n    \"meurtre\",\n    \"sexual\",\n    \"assasin\",\n    \"assassination\",\n    \"pédophile\",\n    \"pedophilia\",\n    \"pedo\",\n    \"tuer\",\n    \"tuerie\",\n    \"tue\",\n    \"inappropriate\",\n    \"nsfw\",\n    \"sex\",\n    \"erotic\",\n];\n// https://www.airbnb.fr/rooms/52621429?adults=2&category_tag=Tag%3A4104&children=0&enable_m3_private_room=true&infants=0&pets=0&photo_id=1667039872&search_mode=flex_destinations_search&check_in=2025-01-03&check_out=2025-01-08&source_impression_id=p3_1732287557_P3IQ3z7DTBGIxxhx&previous_page_section_name=1000\n// Liste de mots-clés sensibles dans les URLs\n/**\n * Vérifie si le site actuel doit être bloqué.\n * @param url L'URL complète de la page web.\n * @returns true si le site est inapproprié, sinon false.\n */\nexport function shouldBlockUrl(url) {\n    try {\n        // Créer une instance d'URL\n        var parsedUrl = new URL(url);\n        // Extraire le domaine (hostname)\n        var domain_1 = parsedUrl.hostname.toLowerCase();\n        // Vérifier si le domaine est dans la liste interdite\n        if (forbiddenDomains.some(function (forbiddenDomain) {\n            return domain_1.includes(forbiddenDomain);\n        })) {\n            console.log(\"URL bloqu\\u00E9e : Domaine interdit (\".concat(domain_1, \")\"));\n            return true;\n        }\n        // Extraire le chemin complet (path)\n        var path_1 = parsedUrl.pathname.toLowerCase();\n        // Vérifier si un mot-clé interdit est dans le chemin\n        if (forbiddenKeywords.some(function (keyword) { return path_1.includes(keyword); })) {\n            console.log(\"URL bloqu\\u00E9e : Mot-cl\\u00E9 interdit dans le chemin (\".concat(path_1, \")\"));\n            return true;\n        }\n        // Extraire les paramètres de requête (query string)\n        var query_1 = parsedUrl.search.toLowerCase();\n        // Vérifier si un mot-clé interdit est dans les paramètres de requête\n        if (forbiddenKeywords.some(function (keyword) { return query_1.includes(keyword); })) {\n            console.log(\"URL bloqu\\u00E9e : Mot-cl\\u00E9 interdit dans les param\\u00E8tres (\".concat(query_1, \")\"));\n            return true;\n        }\n        // Si aucune condition de blocage n'est satisfaite, autoriser l'accès\n        console.log(\"URL autoris\\u00E9e : \".concat(url));\n        return false;\n    }\n    catch (error) {\n        console.error(\"Erreur lors de l'analyse de l'URL : \".concat(error));\n        return true; // Bloquer par défaut en cas d'erreur\n    }\n}\n/* export function isAdultSite(url: string): boolean {\n    const domain = new URL(url).hostname.toLowerCase();\n\n    // Vérifie si le domaine ou l'URL contient des contenus sensibles\n    if (\n        forbiddenDomains.some((blockedDomain) => domain.includes(blockedDomain)) ||\n        forbiddenKeywords.some((keyword) => url.toLowerCase().includes(keyword))\n    ) {\n        return true;\n    }\n\n    return false;\n} */\n","// Enregistrement des tokens\n/* export function setTokens(accessToken: string, refreshToken: string | null) {\n  chrome.storage.local.set({ accessToken, refreshToken }, () => {\n    console.log(\"Tokens enregistrés dans chrome.storage :\", {\n      accessToken,\n      refreshToken,\n    });\n  });\n}\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// Récupération des tokens\n/* export function getTokens(): Promise<{ accessToken: string | null; refreshToken: string | null }> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([\"accessToken\", \"refreshToken\"], (result) => {\n      console.log(\"Tokens récupérés depuis le stockage:\", result);\n      resolve({\n        accessToken: result.accessToken || null,\n        refreshToken: result.refreshToken || null,\n      });\n    });\n  });\n} */\n/*   export function getTokens(): { accessToken: string | null; refreshToken: string | null } {\n    const accessToken = localStorage.getItem('accessToken') || sessionStorage.getItem('accessToken');\n    const refreshToken = localStorage.getItem('refreshToken') || sessionStorage.getItem('refreshToken');\n    return { accessToken, refreshToken };\n  } */\n/*     export async function getTokens(): Promise<{ accessToken: string | null; refreshToken: string | null }> {\n      return new Promise((resolve) => {\n        chrome.storage.local.get([\"accessToken\", \"refreshToken\"], (result) => {\n          console.log(\"Tokens récupérés depuis chrome.storage :\", result);\n          resolve({\n            accessToken: result.accessToken || null,\n            refreshToken: result.refreshToken || null,\n          });\n        });\n      });\n    } */\nvar TWENTY_FIVE_HOURS_IN_MS = 24 * 60 * 60 * 1000;\nvar memoryCache = { accessToken: null };\n// Stocke l'accessToken\nexport function setTokens(accessToken) {\n    memoryCache.accessToken = accessToken; // Cache en mémoire\n    chrome.storage.local.set({ accessToken: accessToken }, function () {\n        console.log(\"AccessToken enregistré dans chrome.storage :\", accessToken);\n    });\n}\nexport function getTokens() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (memoryCache.accessToken) {\n                console.log(\"AccessToken récupéré depuis le cache mémoire :\", memoryCache.accessToken);\n                return [2 /*return*/, { accessToken: memoryCache.accessToken }];\n            }\n            return [2 /*return*/, new Promise(function (resolve) {\n                    chrome.storage.local.get(['accessToken'], function (result) {\n                        console.log(\"AccessToken récupéré depuis chrome.storage :\", result.accessToken);\n                        resolve({ accessToken: result.accessToken || null });\n                    });\n                })];\n        });\n    });\n}\n// Supprime les tokens\nexport function removeTokens() {\n    chrome.storage.local.remove([\"accessToken\", \"refreshToken\"], function () {\n        if (chrome.runtime.lastError) {\n            console.error(\"Erreur lors de la suppression des tokens :\", chrome.runtime.lastError.message);\n        }\n        else {\n            console.log(\"Tokens supprimés de chrome.storage\");\n        }\n    });\n}\n// Stocke l'heure de connexion\nexport function setLoginTime() {\n    var currentTime = Date.now();\n    chrome.storage.local.set({ loginTime: currentTime }, function () {\n        if (chrome.runtime.lastError) {\n            console.error(\"Erreur lors de l'enregistrement de l'heure de connexion :\", chrome.runtime.lastError.message);\n        }\n        else {\n            console.log(\"Heure de connexion enregistrée :\", currentTime);\n        }\n    });\n}\nexport function isTokenExpired() {\n    return __awaiter(this, void 0, void 0, function () {\n        var accessToken, loginTime, currentTime, elapsedTime, tokenLifetime;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, getTokens()];\n                case 1:\n                    accessToken = (_a.sent()).accessToken;\n                    return [4 /*yield*/, new Promise(function (resolve) {\n                            chrome.storage.local.get(['loginTime'], function (result) {\n                                resolve({ loginTime: result.loginTime || null });\n                            });\n                        })];\n                case 2:\n                    loginTime = (_a.sent()).loginTime;\n                    if (!accessToken || !loginTime) {\n                        return [2 /*return*/, true]; // Pas de token ou pas d'heure de connexion\n                    }\n                    currentTime = Date.now();\n                    elapsedTime = currentTime - loginTime;\n                    tokenLifetime = 3600000;\n                    return [2 /*return*/, elapsedTime > tokenLifetime];\n            }\n        });\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getTokens, setTokens } from './utils/storageUtil';\nimport { shouldBlockUrl } from \"./utils/blockAdultSites\";\nimport { logout } from './services/AuthService';\nvar API_URL = 'https://usearlyapi.fly.dev/api/v1';\n//const TWENTY_FIVE_HOURS_IN_MS = 20 * 1000; // 20 secondes pour le test\n//const TWENTY_FIVE_HOURS_IN_MS = 24 * 60 * 60 * 1000;\n/* chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (tab.url && shouldBlockUrl(tab.url)) {\n    console.log(\"Site bloqué : désactivation de l'extension.\");\n    chrome.action.disable(tabId); // Désactive l'icône de l'extension\n  } else {\n    chrome.action.enable(tabId); // Active l'icône de l'extension\n  }\n}); */\nchrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {\n    if (changeInfo.status === 'complete' && tab.url) {\n        if (shouldBlockUrl(tab.url)) {\n            // Envoie un message au content script pour afficher le popup\n            // Injecte le content script pour flouter les médias\n            chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                files: [\"contentScript.js\"], // Assurez-vous que le fichier est compilé en JS\n            });\n            // Ferme l'onglet après un délai de 3 secondes\n            /* setTimeout(() => {\n                chrome.tabs.remove(tabId, () => {\n                    console.log(`Onglet fermé pour contenu inapproprié : ${tab.url}`);\n                });\n            }, 10000);  */ // Délai de 3 secondes avant la fermeture\n        }\n    }\n});\n// Temps avant déconnexion automatique (en ms)\nvar AUTO_LOGOUT_TIME = 24 * 60 * 60 * 1000; // 24h\nvar CHECK_INTERVAL = 5000; // Vérifie toutes les 5 secondes\n// Fonction pour déconnecter automatiquement l'utilisateur\nfunction handleAutoLogout() {\n    console.log(\"Déconnexion automatique en cours...\");\n    logout();\n    // Notification de déconnexion\n    chrome.notifications.create({\n        type: \"basic\",\n        iconUrl: \"/assets/icons/logout-icon.png\",\n        title: \"Déconnexion\",\n        message: \"Vous avez été automatiquement déconnecté.\",\n    });\n    // Envoi d'un message aux scripts de contenu pour gérer l'interface utilisateur\n    chrome.tabs.query({}, function (tabs) {\n        tabs.forEach(function (tab) {\n            if (tab.id) {\n                chrome.tabs.sendMessage(tab.id, { type: \"USER_LOGGED_OUT\" });\n            }\n        });\n    });\n}\n// Vérifie périodiquement si l'utilisateur doit être déconnecté\nsetInterval(function () {\n    chrome.storage.local.get([\"loginTime\"], function (result) {\n        var loginTime = result.loginTime;\n        if (loginTime) {\n            var elapsedTime = Date.now() - loginTime;\n            console.log(\"Temps \\u00E9coul\\u00E9 : \".concat(elapsedTime / 1000, \" secondes\"));\n            if (elapsedTime >= AUTO_LOGOUT_TIME) {\n                handleAutoLogout();\n            }\n        }\n        else {\n            console.log(\"Aucune donnée de connexion trouvée.\");\n        }\n    });\n}, CHECK_INTERVAL);\nchrome.action.onClicked.addListener(function (tab) {\n    console.log(\"Icône de l'extension cliquée.\", tab);\n    console.log(\"Envoi du message à content.js...\");\n    if (tab.id) {\n        chrome.tabs.sendMessage(tab.id, { action: \"showFloatingMenu\" }, function (response) {\n            if (chrome.runtime.lastError) {\n                console.error(\"Erreur de communication avec content.js :\", chrome.runtime.lastError.message);\n            }\n            else {\n                console.log(\"Réponse de content.js :\", response);\n            }\n        });\n    }\n    else {\n        console.error(\"Aucun onglet actif trouvé !\");\n    }\n});\n// Gestion des messages entrants\nchrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {\n    console.log(\"Message reçu dans le script de fond :\", message);\n    switch (message.action) {\n        case \"captureTab\":\n            chrome.windows.getCurrent({ populate: false }, function (window) {\n                var windowId = window === null || window === void 0 ? void 0 : window.id;\n                if (typeof windowId === \"number\") {\n                    chrome.tabs.captureVisibleTab(windowId, { format: \"png\" }, function (dataUrl) {\n                        if (chrome.runtime.lastError) {\n                            console.log(\"Erreur de capture d'onglet :\", chrome.runtime.lastError.message);\n                            sendResponse({ success: false, error: chrome.runtime.lastError.message });\n                        }\n                        else {\n                            sendResponse({ success: true, dataUrl: dataUrl });\n                        }\n                    });\n                }\n                else {\n                    sendResponse({ success: false, error: \"ID de fenêtre non valide.\" });\n                }\n            });\n            return true; // Assurez-vous de retourner `true` pour les réponses asynchrones\n        case \"login\":\n            var email = message.email, password = message.password;\n            console.log(\"Tentative de connexion pour l'utilisateur :\", email);\n            try {\n                var timeout_1 = setTimeout(function () {\n                    console.log(\"Timeout pour la requête de connexion.\");\n                    sendResponse({ success: false, error: 'Request timeout' });\n                }, 5000); // Timeout de 5 secondes\n                fetch(\"\".concat(API_URL, \"/user/login\"), {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    mode: 'cors',\n                    body: JSON.stringify({ email: email, password: password }),\n                })\n                    .then(function (response) { return response.json(); })\n                    .then(function (data) {\n                    console.log(\"data: \", data);\n                    clearTimeout(timeout_1); // Annule le timeout si la réponse arrive\n                    if (data.accessToken) {\n                        setTokens(data.accessToken);\n                        chrome.storage.local.set({ loginTime: Date.now() }); // Enregistre l'heure de connexion\n                        console.log(\"Connexion réussie. Tokens stockés.\");\n                        sendResponse({ success: true });\n                    }\n                    else {\n                        console.log(\"Échec de l'authentification : aucun token reçu.\");\n                        sendResponse({ success: false, error: 'Authentification échouée' });\n                    }\n                })\n                    .catch(function (error) {\n                    clearTimeout(timeout_1);\n                    console.log(\"Erreur de connexion :\", error);\n                    sendResponse({ success: false, error: error.message });\n                });\n            }\n            catch (error) {\n                console.log(\"Erreur inattendue :\", error);\n                sendResponse({ success: false, error: 'Erreur interne' });\n            }\n            return true; // Retourner `true` pour les opérations asynchrones\n        case \"USER_LOGGED_OUT\":\n            handleAutoLogout(); // Appelle la fonction de déconnexion\n            sendResponse({ success: true });\n            return false;\n        case \"isAuthenticated\":\n            console.log(\"Vérification de l'authentification de l'utilisateur.\");\n            getTokens().then(function (tokens) {\n                sendResponse({ isAuthenticated: !!tokens.accessToken });\n            });\n            return true; // Permet la réponse asynchrone\n        case \"test\":\n            console.log(\"Message de test reçu du script de contenu.\");\n            sendResponse({ success: true });\n            return false;\n        default:\n            console.log(\"Action non reconnue :\", message.action);\n            sendResponse({ success: false, error: \"Action non reconnue\" });\n            return false;\n    }\n});\n"],"names":[],"sourceRoot":""}